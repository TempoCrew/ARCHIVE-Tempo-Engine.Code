package engine.backend.util.plugins;

#if FEATURE_CRASH_DIALOG
import engine.backend.util.DateUtil;
import flixel.util.FlxSignal.FlxTypedSignal;
import openfl.events.UncaughtErrorEvent;

/**
 * Game crash full information dialog.
 *
 * `NULL OBJECT REFERENCE` and etc.
 */
@:nullSafety
class CrashPlugin
{
	/**
	 * Initialize a crash dialog.
	 */
	public static function init()
	{
		Sys.println('Crash Log: Standard uncaught error handler enabling...');
		Lib.current.loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, standardError);

		#if (cpp && FEATURE_CRITICAL_CRASH) // for debug build removed this, because... this for debug no cool :D
		Sys.println('Crash Log: C++ critical error handler enabling...');
		untyped __global__.__hxcpp_set_critical_error_handler(criticalError);
		#end
	}

	/**
	 * Standard crash for all platforms.
	 */
	public static var standardSignal(default, null):FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();

	/**
	 * Standard crash dialog calling function.
	 *
	 * @param e Error Event
	 */
	static function standardError(e:UncaughtErrorEvent)
	{
		#if FEATURE_DISCORD_RPC
		DiscordClient.instance.shutdown();
		#end

		#if FEATURE_GAMEJOLT_CLIENT
		GameJoltClient.instance.closeSession();
		#end

		try
		{
			standardSignal.dispatch(CrashReference.generateMsg(e));

			#if sys
			CrashReference.logError(e);
			#end

			CrashReference.displayError(e);
		}
		catch (e)
			Sys.println('Crash Log: Handling Error: $e');

		System.exit(1);
	}

	#if (cpp && FEATURE_CRITICAL_CRASH)
	/**
	 * Critical crash dialog for platforms, supported a `C++` (Windows, Linux and etc).
	 */
	public static var criticalSignal(default, null):FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();

	/**
	 * Critical crash dialog calling function.
	 *
	 * @param e Error Text
	 */
	static function criticalError(e:String)
	{
		#if FEATURE_DISCORD_RPC
		DiscordClient.instance.shutdown();
		#end

		#if FEATURE_GAMEJOLT_CLIENT
		GameJoltClient.instance.closeSession();
		#end

		try
		{
			criticalSignal.dispatch(e);

			#if sys
			CrashReference.logErrorMsg(e, true);
			#end

			@:privateAccess CrashReference.displayErrorMsg(e #if windows, "Critical Error" #end);
		}
		catch (e)
		{
			Sys.println('Crash Log: Critical Handling Error: $e');
			Sys.println('Message: $e');
		}

		System.exit(1);
	}
	#end

	/**
	 * Constant for cool
	 */
	static final pr:String = "======================";

	/**
	 * Creating a content to text file.
	 * @param msg Error Message
	 */
	public static function createContent(msg:String):String
	{
		final driverInfo:String = FlxG?.stage?.context3D?.driverInfo ?? 'N\\A';
		final curState:String = FlxG.state != null ? Type.getClassName(Type.getClass(FlxG.state)) : 'Unknown State';

		var fc:String = '$pr\n';
		fc += '| Tempo Crash Dialog |\n';
		fc += '$pr\n\n';
		fc += 'Generated By: Crash Log Exporter (${Constants.GENERATED_BY})\n';
		fc += 'Crashed at: ${DateUtil.generateTimestamp()}\n';
		fc += 'Driver Info: ${driverInfo}\n';
		fc += 'Platform: ${tempo.util.TempoSystem.get_OS_info()}\n';
		fc += 'Render method: ${CrashReference.renderMethod()}\n\n';
		fc += MemoryUtil.buildGCInfo() + '\n\n';
		fc += '$pr\n\n';
		fc += 'Flixel Current State: ${curState}\n\n';
		fc += '$pr\n\n';
		fc += 'Haxelibs:\n';

		for (lib in Constants.LIBRARY_VERSION)
			fc += '- ${lib}\n';

		fc += '\n';
		fc += '$pr\n\n';
		fc += msg;
		fc += '\n';

		return fc;
	}
}

@:keep
@:access(engine.util.plugins.CrashPlugin)
private class CrashReference
{
	static var file:String = "";

	static final pr:String = "======================";

	public static function displayError(e:UncaughtErrorEvent):Void
		displayErrorMsg(generateMsg(e) #if windows, generateFirMsg(e) #end);

	public static function displayErrorMsg(e:String #if windows, msg:String #end):Void
	{
		#if windows
		final appName:String = (openfl.Lib.application.meta.get('file') != null ? openfl.Lib.application.meta.get('file') : 'Tempo Engine') + ".exe";
		final app = '${Sys.getCwd()}${Constants.CRASH_APP}';
		final args = '"$msg" "$e" "$file" "${Constants.GITHUB_URL}/issues" "$appName"';

		WindowsUtil.createProcess(app, args);
		#else
		openfl.Lib.application.window.alert('| TEMPO CRASH LOG |'
			+ '\n'
			+ pr
			+ '\n'
			+ e
			+ '\n'
			+ pr
			+ '\n\n'
			+ 'Generated By: Crash Log Exporter (${Constants.GENERATED_BY})'
			+ '\n'
			+ 'Reporting to: ${Constants.GITHUB_URL}/issues',
			"FATAL UNCAUGHT ERROR");
		#end

		#if sys
		Sys.println(#if windows '\n$msg\n\n' + #end e.replace('$', '\n'));
		#else
		trace(e.replace('$', '\n'));
		#end
	}

	#if sys
	public static function logError(e:UncaughtErrorEvent)
	{
		logErrorMsg(generateMsg(e));
	}

	public static function logErrorMsg(e:String, c:Bool = false)
	{
		if (!FileSystem.exists('./logs/'))
			FileSystem.createDirectory('./logs');

		Sys.println("\nGame crash dump in: " + haxe.io.Path.normalize('./logs/tempo-crash${c ? '-critical' : ''}-${DateUtil.generateTimestamp()}.log'));

		file = "tempo-crash" + (c ? '-critical' : '') + '-' + DateUtil.generateTimestamp();

		File.saveContent('./logs/$file.log', CrashPlugin.createContent(e));
	}
	#end

	public static function renderMethod():String
	{
		var output:String = 'UNKNOWN';
		output = try
		{
			switch (FlxG.renderMethod)
			{
				case FlxRenderMethod.DRAW_TILES: 'DRAW_TILES';
				case FlxRenderMethod.BLITTING: "BLITTING";
				default: 'UNKNOWN';
			}
		}
		catch (e)
			'ERROR ON QUERY RENDER METHOD: $e';

		return output;
	}

	#if windows
	static function generateFirMsg(e:UncaughtErrorEvent):String
		return Std.string(e.error);
	#end

	public static function generateMsg(e:UncaughtErrorEvent):String
	{
		var msg:String = "";
		var callStack:Array<haxe.CallStack.StackItem> = haxe.CallStack.exceptionStack(true);

		#if !windows
		msg += '${e.error}\n';

		for (stackItem in callStack)
		{
			switch (stackItem)
			{
				case FilePos(innerStackItem, file, line, column):
					msg += ' ${file}#${line}' + (innerStackItem != null ? ' ${innerStackItem}' : '');
					if (column != null)
						msg += ':${column}';
				case CFunction:
					msg += '[Function] ';
				case Module(m):
					msg += '[Module(${m})] ';
				case Method(classname, method):
					msg += '[Function(${classname}.${method})] ';
				case LocalFunction(v):
					msg += '[LocalFunction(${v})] ';
				default:
					Sys.println(stackItem);
			}
			msg += '\n';
		}
		#else
		for (stackItem in callStack)
		{
			switch (stackItem)
			{
				case FilePos(innerStackItem, file, line, column):
					msg += '${file}#${line}' + (innerStackItem != null ? ' ${innerStackItem}' : '');
					if (column != null)
						msg += ':${column}';
				case CFunction:
					msg += '[Function] ';
				case Module(m):
					msg += '[Module(${m})] ';
				case Method(classname, method):
					msg += '[Function(${classname}.${method})] ';
				case LocalFunction(v):
					msg += '[LocalFunction(${v})] ';
				default:
					Sys.println(stackItem);
			}
			msg += '$';
		}
		#end

		return msg;
	}
}
#end
